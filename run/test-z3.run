build "core init test/z3 drivers/timer drivers/rtc"

create_boot_directory

install_config {
<config verbose="no">
	<parent-provides>
		<service name="ROM"/>
		<service name="RAM"/>
		<service name="IRQ"/>
		<service name="IO_MEM"/>
		<service name="IO_PORT"/>
		<service name="CAP"/>
		<service name="PD"/>
		<service name="RM"/>
		<service name="CPU"/>
		<service name="LOG"/>
		<service name="SIGNAL"/>
	</parent-provides>
	<default-route>
		<any-service> <parent/> <any-child/> </any-service>
	</default-route>
	<start name="timer">
		<resource name="RAM" quantum="1M"/>
		<provides> <service name="Timer"/> </provides>
	</start>
	<start name="rtc_drv">
		<resource name="RAM" quantum="1M"/>
		<provides> <service name="Rtc"/> </provides>
	</start>
	<start name="test-z3-c">
		<exit propagate="yes"/>
		<resource name="RAM" quantum="2M"/>
		<config>
			<libc stdin="/dev/null" stdout="/dev/log" stderr="/dev/log" rtc="/dev/rtc">
				<vfs>
					<dir name="dev"> <log/> <null/> <rtc/> </dir>
				</vfs>
			</libc>
		</config>
	</start>
</config>
}

build_boot_image {
	core init test-z3-c test-z3-c++ timer rtc_drv
	ld.lib.so libc.lib.so libm.lib.so
	stdcxx.lib.so z3.lib.so
}

append qemu_args " -nographic -m 512 "

run_genode_until {.*child "init" exited with exit value 0.*} 300

grep_output {^\[init \-\> test\-z3\-c\] }

# remove resource requests
unify_output {\[init -> test-z3-c\] resource_request: ram_quota=[0-9]+\n} ""
unify_output {\[init -> test-z3-c\] Cannot register exit handler - ATEXIT_SIZE reached\n} ""
unify_output {\[init -> test-z3-c\] int setrlimit\(int, const rlimit\*\)\: setrlimit not implemented\n} ""
unify_output {\[init -> test-z3-c\] virtual void Genode\:\:Platform_env\:\:release\(\)\: used after freeing emergency=[0-9]+\n} ""
unify_output {\[init -> test-z3-c\] virtual void Genode\:\:Platform_env\:\:release\(\)\: used before freeing emergency=[0-9]+\n} ""
unify_output {\[init -> test-z3-c\] int _sigprocmask\(int, const sigset_t\*, sigset_t\*\)\: _sigprocmask not implemented\n} ""
unify_output {\[init -> test-z3-c\] } ""

compare_output_to {
Z3 4.4.2.0

simple_example

DeMorgan
DeMorgan is valid

find_model_example1
model for: x xor y
sat
x -> false
y -> true


find_model_example2
model for: x < y + 1, x > 2
sat
x -> 3
y -> 3

model for: x < y + 1, x > 2, not(x = y)
sat
y -> 4
x -> 3


prove_example1
prove: x = y implies g(x) = g(y)
valid
disprove: x = y implies g(g(x)) = g(y)
invalid
counterexample:
y -> U!val!0
x -> U!val!0
g -> {
  U!val!0 -> U!val!1
  U!val!1 -> U!val!2
  else -> U!val!1
}


prove_example2
prove: not(g(g(x) - g(y)) = g(z)), x + z <= y <= x implies z < 0
valid
disprove: not(g(g(x) - g(y)) = g(z)), x + z <= y <= x implies z < -1
invalid
counterexample:
z -> (- 1)
y -> 1236
x -> 1236
g -> {
  1236 -> 0
  0 -> 2
  (- 1) -> 3
  else -> 0
}


push_pop_example1
assert: x >= 'big number'
push
number of scopes: 1
assert: x <= 3
unsat
pop
number of scopes: 0
sat
x = 1000000000000000000000000000000000000000000000000000000:int
function interpretations:
assert: y > x
sat
y = 1000000000000000000000000000000000000000000000000000001:int
x = 1000000000000000000000000000000000000000000000000000000:int
function interpretations:

quantifier_example1
pattern: ((f (:var 0) (:var 1)))

assert axiom:
(forall ((x!1 Int) (x!2 Int))
  (! (= (inv!0 (f x!2 x!1)) x!1) :pattern ((f x!2 x!1))))
prove: f(x, y) = f(w, v) implies y = v
valid
disprove: f(x, y) = f(w, v) implies x = w
that is: not(f(x, y) = f(w, v) implies x = w) is satisfiable
unknown
potential model:
w = 2:int
v = 1:int
y = 1:int
x = 0:int
function interpretations:
f = {(else|->(declare-fun f!52 (Int Int) Int)[(declare-fun k!50 (Int) Int)[#unknown], (declare-fun k!51 (Int) Int)[#unknown]])}
#51 = {(2:int|->2:int), (1:int|->1:int), (15:int|->15:int), (11:int|->11:int), (0:int|->0:int), (19:int|->19:int), (else|->2:int)}
f!52 = {(0:int, 1:int|->3:int), (2:int, 1:int|->3:int), (0:int, 0:int|->4:int), (2:int, 0:int|->5:int), (6:int, 2:int|->7:int), (2:int, 2:int|->8:int), (0:int, 2:int|->9:int), (6:int, 0:int|->10:int), (0:int, 11:int|->12:int), (6:int, 11:int|->13:int), (2
:int, 11:int|->14:int), (0:int, 15:int|->16:int), (2:int, 15:int|->17:int), (6:int, 15:int|->18:int), (6:int, 19:int|->20:int), (2:int, 19:int|->21:int), (0:int, 19:int|->22:int), (else|->3:int)}
inv!0 = {(3:int|->1:int), (4:int|->0:int), (5:int|->0:int), (7:int|->2:int), (8:int|->2:int), (9:int|->2:int), (10:int|->0:int), (12:int|->11:int), (13:int|->11:int), (14:int|->11:int), (16:int|->15:int), (17:int|->15:int), (18:int|->15:int), (20:int|->19
:int), (21:int|->19:int), (22:int|->19:int), (else|->2:int)}
#50 = {(2:int|->2:int), (6:int|->6:int), (0:int|->0:int), (else|->2:int)}
reason for last failure: (incomplete quantifiers)

array_example1
prove: store(a1, i1, v1) = store(a2, i2, v2) implies (i1 = i3 or i2 = i3 or select(a1, i3) = select(a2, i3))
(=> (= (store a1 i1 v1) (store a2 i2 v2))
    (or (= i1 i3) (= i2 i3) (= (select a1 i3) (select a2 i3))))
valid

array_example2
n = 2
(distinct k!0 k!1)
sat
#1 = (declare-fun const (Bool) (Array Bool Bool))[(declare-fun false () Bool)]
#0 = (declare-fun store ((Array Bool Bool) Bool Bool) (Array Bool Bool))[(declare-fun const (Bool) (Array Bool Bool))[(declare-fun false () Bool)], (declare-fun false () Bool), (declare-fun true () Bool)]
function interpretations:
n = 3
(distinct k!0 k!1 k!2)
sat
#0 = (declare-fun as-array () (Array Bool Bool))
#1 = (declare-fun as-array () (Array Bool Bool))
#2 = (declare-fun as-array () (Array Bool Bool))
function interpretations:
#0 = {((declare-fun true () Bool)|->(declare-fun true () Bool)), ((declare-fun false () Bool)|->(declare-fun false () Bool)), (else|->(declare-fun true () Bool))}
#1 = {((declare-fun false () Bool)|->(declare-fun true () Bool)), (else|->(declare-fun true () Bool))}
#2 = {((declare-fun true () Bool)|->(declare-fun false () Bool)), ((declare-fun false () Bool)|->(declare-fun false () Bool)), (else|->(declare-fun false () Bool))}
n = 4
(distinct k!0 k!1 k!2 k!3)
sat
#0 = (declare-fun as-array () (Array Bool Bool))
#1 = (declare-fun as-array () (Array Bool Bool))
#2 = (declare-fun as-array () (Array Bool Bool))
#3 = (declare-fun as-array () (Array Bool Bool))
function interpretations:
#0 = {((declare-fun true () Bool)|->(declare-fun false () Bool)), ((declare-fun false () Bool)|->(declare-fun true () Bool)), (else|->(declare-fun false () Bool))}
#1 = {((declare-fun true () Bool)|->(declare-fun true () Bool)), ((declare-fun false () Bool)|->(declare-fun false () Bool)), (else|->(declare-fun true () Bool))}
#2 = {((declare-fun true () Bool)|->(declare-fun true () Bool)), ((declare-fun false () Bool)|->(declare-fun true () Bool)), (else|->(declare-fun true () Bool))}
#3 = {((declare-fun true () Bool)|->(declare-fun false () Bool)), ((declare-fun false () Bool)|->(declare-fun false () Bool)), (else|->(declare-fun false () Bool))}
n = 5
(distinct k!0 k!1 k!2 k!3 k!4)
unsat

array_example3
domain: int
range:  bool

tuple_example1
tuple_sort: (real, real)
prove: get_x(mk_pair(x, y)) = 1 implies x = 1
valid
disprove: get_x(mk_pair(x, y)) = 1 implies y = 1
invalid
counterexample:
y -> 0.0
x -> 1.0

prove: get_x(p1) = get_x(p2) and get_y(p1) = get_y(p2) implies p1 = p2
valid
disprove: get_x(p1) = get_x(p2) implies p1 = p2
invalid
counterexample:
p1 -> (mk_pair 1.0 0.0)
p2 -> (mk_pair 1.0 2.0)

prove: p2 = update(p1, 0, 10) implies get_x(p2) = 10
valid
disprove: p2 = update(p1, 0, 10) implies get_y(p2) = 10
invalid
counterexample:
p2 -> (mk_pair 10.0 1.0)
p1 -> (mk_pair 0.0 1.0)


bitvector_example1
disprove: x - 10 <= 0 IFF x <= 10 for (32-bit) machine integers
invalid
counterexample:
x -> #x80000008


bitvector_example2
find values of x and y, such that x ^ y - 103 == x * y
sat
y -> #x2c330437
x -> #x656fe436


eval_example1
MODEL:
x -> 3
y -> 4

evaluating x+y
result = 7:int

two_contexts_example1
k!0

error_code_example1
last call succeeded.
last call failed.

error_code_example2
before Z3_mk_iff
Z3 error: Z3 exception.

parser_example1
formula 0: (> x y)
formula 1: (> x 0)
sat
x -> 1
y -> 0


parser_example2
formula: (> x y)
sat
y -> 0
x -> 1


parser_example3
assert axiom:
(forall ((x Int) (y Int)) (= (g x y) (g y x)))
formula: (forall ((x Int) (y Int)) (=> (= x y) (= (g x 0) (g 0 y))))
valid

parser_example4
declaration 0: (declare-fun y () Int)
declaration 1: (declare-fun sk_hack (Bool) Bool)
declaration 2: (declare-fun x () Int)
assumption 0: (= x 20)
formula 0: (> x y)
formula 1: (> x 0)

parser_example5
Z3 error: parser error.

numeral_example
Numerals n1:(/ 1.0 2.0) n2:(/ 1.0 2.0)
valid
Numerals n1:(- (/ 1.0 3.0)) n2:(- (/ 33333333333333333333333333333333333333333333333333.0
      100000000000000000000000000000000000000000000000000.0))
valid

ite_example
term: (ite false 1 0)

list_example
valid
valid
valid
valid
valid
valid
valid
Formula (=> (is_cons u) (= u (cons (head u) (tail u))))
valid
invalid
counterexample:
u -> nil


tree_example
valid
valid
valid
valid
valid
Formula (=> (is_cons u) (= u (cons (car u) (cdr u))))
valid
invalid
counterexample:
u -> nil


forest_example
valid
valid
valid
valid
valid
valid

binary_tree_example
valid
valid
valid
valid
valid

enum_example
(declare-fun apple () fruit)
(declare-fun banana () fruit)
(declare-fun orange () fruit)
(declare-fun is_apple (fruit) Bool)
(declare-fun is_banana (fruit) Bool)
(declare-fun is_orange (fruit) Bool)
valid
valid
invalid
counterexample:

valid
valid

unsat_core_and_proof_example
unsat
proof: (let ((a!1 (def-axiom (or (or (not PredA) PredB (not PredC)) (not PredB))))
      (a!2 (def-axiom (or (or (not PredA) (not PredB) (not PredC)) PredB)))
      (a!3 (= (and PredA PredB PredC)
              (not (or (not PredA) (not PredB) (not PredC)))))
      (a!4 (or (not (or (not PredA) (not PredB) (not PredC))) P1))
      (a!8 (asserted (or (and PredA (not PredB) PredC) P2)))
      (a!9 (= (and PredA (not PredB) PredC)
              (not (or (not PredA) PredB (not PredC)))))
      (a!10 (or (not (or (not PredA) PredB (not PredC))) P2)))
(let ((a!5 (monotonicity (rewrite a!3) (= (or (and PredA PredB PredC) P1) a!4)))
      (a!11 (= (or (and PredA (not PredB) PredC) P2) a!10)))
(let ((a!6 (mp (asserted (or (and PredA PredB PredC) P1)) a!5 a!4))
      (a!12 (unit-resolution (mp a!8 (monotonicity (rewrite a!9) a!11) a!10)
                             (asserted (not P2))
                             (not (or (not PredA) PredB (not PredC))))))
(let ((a!7 (unit-resolution a!6
                            (asserted (not P1))
                            (not (or (not PredA) (not PredB) (not PredC))))))
  (unit-resolution a!1 (unit-resolution a!2 a!7 PredB) a!12 false)))))

core:
(not P1)
(not P2)


incremental_example1
unsat core: 0 2 3 
unsat
sat
unsat core: 0 2 3 
unsat
unsat core: 0 2 3 
unsat
sat

reference_counter_example
model for: x xor y
sat
x -> false
y -> true


smt2parser_example
formulas: (and (bvuge a #x10) (bvule a #xf0))

substitute_example
substitution result: (f (f a 0) 1)

substitute_vars_example
substitution result: (f (f a (g b)) a)

FPA-example
c4: (and (= x_plus_y (fp.add rm x y))
     (= x_plus_y (fp #b0 #b10000000100 #x5000000000000))
     (not (= rm roundTowardZero))
     (not (fp.isZero y))
     (not (fp.isNaN y))
     (not (fp.isInfinite y)))
sat
y -> (fp #b1 #b10000000010 #x4000000000002)
x_plus_y -> (fp #b0 #b10000000100 #x5000000000000)
rm -> roundNearestTiesToEven
x -> (fp #b0 #b10000000100 #xa000000000000)

c5: (and (= (fp #b0 #b10000000001 #xc000000000000)
        ((_ to_fp 11 53) #x401c000000000000))
     (= (fp #b0 #b10000000001 #xc000000000000)
        ((_ to_fp 11 53) roundTowardZero 2 (/ 7.0 4.0)))
     (= (fp #b0 #b10000000001 #xc000000000000)
        ((_ to_fp 11 53) roundTowardZero 7.0)))
sat

}
